// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Screen.jack

/**
 * A library of functions for displaying graphics on the screen.
 * The Hack physical screen consists of 512 rows (indexed 0..511, top to bottom)
 * of 256 pixels each (indexed 0..255, left to right). The top left pixel on 
 * the screen is indexed (0,0).
 */
class Screen {
  static Array SCREEN;
  static Array BITMASK;
  static boolean m_pin_color;

  // For div_mod()
  static int m_quotient;
  static int m_modulus;

  /** Initializes the Screen. */
  function void init() {
    var int idx;
    var int tmp;

    let BITMASK = Array.new(16);
    let idx = 0;
    let tmp = 1;

    while (idx < 16)
    {
      let BITMASK[idx] = tmp;
      let tmp = tmp + tmp;
      let idx = idx + 1;
    }

    let m_pin_color = true;
    let SCREEN = 16384;

    return;
  }

  /** Erases the entire screen. */
  function void clearScreen() {
    var int i;
    let i = 0;

    // 16 * 512
    while( i < 8192 ) {
      let SCREEN[i] = 0;
      let i = i + 1;
    }
    return;
  }

  /** Sets the current color, to be used for all subsequent drawXXX commands.
   *  Black is represented by true, white by false. */
  function void setColor(boolean b) {
    let m_pin_color = b;
    return;
  }

  /** Draws the (x,y) pixel, using the current color. */
  function void drawPixel(int x, int y) {
    var int offset;
    var int value;
    var int bit;

    let offset = (x / 16) + (y * 32);
    let value = SCREEN[offset];

    do Screen.div_mod(x, 16);
    let bit = m_modulus;

    if (m_pin_color)
    {
      let SCREEN[offset] = value | BITMASK[bit];
    }
    else
    {
      let SCREEN[offset] = value & (~BITMASK[bit]);
    }

    return;
  }

  /** Draws a line from pixel (x1,y1) to pixel (x2,y2), using the current color. */
  function void drawLine(int x1, int y1, int x2, int y2) {
    var int tmp;
    var int start_pixel, stop_pixel;
    var int start_word_offset, stop_word_offset;
    var int mask;
    var int bit_idx;
    var int dx, dy, sx, sy, error, pixel, word_offset, e2;

    // normalize
    if (x1 > x2)
    {
      let tmp = x1;
      let x1 = x2;
      let x2 = tmp;

      let tmp = y1;
      let y1 = y2;
      let y2 = tmp;
    }

    // horizontal line
    if (y1 = y2)
    {
      // determine start/stop offsets
      do Screen.div_mod(x1, 16);

      let start_pixel = m_modulus;
      let start_word_offset = m_quotient + (y1 * 32);

      do Screen.div_mod(x2, 16);

      let stop_pixel = m_modulus;
      let stop_word_offset = m_quotient + (y2 * 32);

      // Special case:
      // start_word_mask and stop_word_mask are at the same location
      if (start_word_offset = stop_word_offset)
      {
        let bit_idx = 15 - start_pixel;
        let mask = 0;
        while (~(bit_idx < (15 - stop_pixel)))
        {
          let mask = mask | BITMASK[15 - bit_idx];
          let bit_idx = bit_idx - 1;
        }

        if (m_pin_color) {
          let SCREEN[start_word_offset] = SCREEN[start_word_offset] | mask;
        }
        else {
          let SCREEN[start_word_offset] = SCREEN[start_word_offset] & ~mask;
        }
      }
      else
      {
        // Start word
        let bit_idx = 15 - start_pixel;
        let mask = 0;
        while (~(bit_idx < 0))
        {
          let mask = mask | BITMASK[15 - bit_idx];
          let bit_idx = bit_idx - 1;
        }

        if (m_pin_color) {
          let SCREEN[start_word_offset] = SCREEN[start_word_offset] | mask;
        }
        else {
          let SCREEN[start_word_offset] = SCREEN[start_word_offset] & ~mask;
        }

        // The between words
        let start_word_offset = start_word_offset + 1;
        while (start_word_offset < stop_word_offset)
        {
          if (m_pin_color) {
            let SCREEN[start_word_offset] = -1;
          }
          else {
            let SCREEN[start_word_offset] = 0;
          }
          let start_word_offset = start_word_offset + 1;
        }

        // End word
        let bit_idx = 15 - stop_pixel;
        let mask = 0;
        while (~(15 < bit_idx))
        {
          let mask = mask | BITMASK[15 - bit_idx];
          let bit_idx = bit_idx + 1;
        }

        if (m_pin_color) {
          let SCREEN[start_word_offset] = SCREEN[start_word_offset] | mask;
        }
        else {
          let SCREEN[start_word_offset] = SCREEN[start_word_offset] & ~mask;
        }
      }

      return;
    }

    // vertical line
    if (x1 = x2)
    {
      // normalize
      if (y1 > y2)
      {
        let tmp = y1;
        let y1 = y2;
        let y2 = tmp;
      }

      do Screen.div_mod(x1, 16);
      let start_pixel = m_modulus;
      let start_word_offset = m_quotient + (y1 * 32);
      let stop_word_offset = m_quotient + (y2 * 32);

      let mask = BITMASK[start_pixel];

      while (~(start_word_offset > stop_word_offset))
      {
        if (m_pin_color) {
          let SCREEN[start_word_offset] = SCREEN[start_word_offset] | mask;
        }
        else {
          let SCREEN[start_word_offset] = SCREEN[start_word_offset] & ~mask;
        }
        let start_word_offset = start_word_offset + 32;
      }

      return;
    }

    // diagonal line: Bresenham's line algorithm
    let dx = Math.abs(x2 - x1);
    let dy = -Math.abs(y2 - y1);

    if (x1 < x2) {
      let sx = 1;
    } else {
      let sx = -1;
    }

    if (y1 < y2) {
      let sy = 1;
    } else {
      let sy = -1;
    }

    let error = dx + dy;

    while (true) {
      do Screen.div_mod(x1, 16);
      let pixel = m_modulus;
      let mask = BITMASK[pixel];
      let word_offset = m_quotient + (y1 * 32);

      if (m_pin_color) {
        let SCREEN[word_offset] = SCREEN[word_offset] | mask;
      }
      else {
        let SCREEN[word_offset] = SCREEN[word_offset] & ~mask;
      }

      if ((x1 = x2) & (y1 = y2)) {
        return;
      }

      let e2 = error + error;

      if (~(e2 < dy)) {
        if (x1 = x2) {
          return;
        }
        let error = error + dy;
        let x1 = x1 + sx;
      }

      if (~(e2 > dx)) {
        if (y1 = y2) {
          return;
        }
        let error = error + dx;
        let y1 = y1 + sy;
      }
    }

    return;
  }

  /** Draws a filled rectangle whose top left corner is (x1, y1)
   * and bottom right corner is (x2,y2), using the current color. */
  function void drawRectangle(int x1, int y1, int x2, int y2) {
    if ((x1 > x2) | ( y1 > y2)) {
      do Sys.error(9);
    }

    while (y2 > y1) {
      do Screen.drawLine(x1, y1, x2, y1);
      let y1 = y1 + 1;
    }

    return;
  }

  /** Draws a small filled circle for r < 12 */
  function void _drawSmallCircle(int x, int y, int r) {
      var int dx, dy;
      var int r_squared, dist_squared;

      // Handle very small circles with patterns
      if (r = 1) {
          // Plus pattern for r=1
          do Screen.drawPixel(x, y);
          do Screen.drawPixel(x-1, y);
          do Screen.drawPixel(x+1, y);
          do Screen.drawPixel(x, y-1);
          do Screen.drawPixel(x, y+1);
          return;
      }

      if (r = 2) {
          // 5x5 diamond for r=2
          do Screen.drawPixel(x, y-2);
          do Screen.drawLine(x-1, y-1, x+1, y-1);
          do Screen.drawLine(x-2, y, x+2, y);
          do Screen.drawLine(x-1, y+1, x+1, y+1);
          do Screen.drawPixel(x, y+2);
          return;
      }

      // For r >= 3, use standard algorithm without bias
      // See: Midpoint circle algorithm
      let r_squared = r * r;
      let dy = -r;

      while (~(dy > r)) {
          // Find the exact boundary
          let dist_squared = r_squared - (dy * dy);
          let dx = 0;

          // Find largest dx where dx^2 <= r^2 - dy^2
          while ((dx * dx) < (dist_squared + 1)) {
              let dx = dx + 1;
          }
          let dx = dx - 1;

          if (dx > -1) {
              do Screen.drawLine(x - dx, y + dy, x + dx, y + dy);
          }

          let dy = dy + 1;
      }
      return;
  }

  /** Draws a filled circle of radius r<=181 around (x,y), using the current color. */
  function void drawCircle(int x, int y, int r) {
    var int dx, dy;
    var int r_squared;

    if (r < 12) {
      do Screen._drawSmallCircle(x, y, r);
      return;
    }

    let dy = -r;
    let r_squared = r * r;

    while (~(dy > r)) {
      let dx = Math.sqrt(r_squared - (dy * dy));
      do Screen.drawLine(x - dx, y + dy, x + dx, y + dy);
      let dy = dy + 1;
    }
    return;
  }

  /* Combined divide/modulus function; returns results in static vars
   * m_quotient and m_modulus. */
  function void div_mod(int dividend, int divisor) {
    var int partial_dividend;
    var int idx;
    var boolean isNegative;

    let isNegative = ((dividend < 0) & ~(divisor < 0)) | (~(dividend < 0) & (divisor < 0));
    let dividend = Math.abs(dividend);
    let divisor = Math.abs(divisor);

    if (divisor > dividend) {
      let m_quotient = 0;
      let m_modulus = dividend;
    }

    if (divisor = 0) {
      do Sys.error(3);
    }

    let m_quotient = 0;
    let partial_dividend = 0;
    let idx = 15;

    while (idx > -1)
    {
      if ((dividend & BITMASK[idx]) > 0)
      {
        let partial_dividend = partial_dividend + partial_dividend + 1;
      }
      else
      {
        let partial_dividend = partial_dividend + partial_dividend;
      }

      if (divisor > partial_dividend)
      {
        let m_quotient = m_quotient + m_quotient + 0;
      }
      else
      {
        let partial_dividend = partial_dividend - divisor;
        let m_quotient = m_quotient + m_quotient + 1;
      }

      let idx = idx - 1;
    }

    if (isNegative)
    {
      let m_modulus = -partial_dividend;
      let m_quotient = -m_quotient;
    }
    else
    {
      let m_modulus = partial_dividend;
    }

    return;
  }
}
