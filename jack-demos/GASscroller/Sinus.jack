/**
 * Sinus static class provides sine table and getter functions.
 *
 * Version 1.5
 *
 * Must be initialised through init() before first use.
 *
 * Copyright 2013-2016 Gavin Stewart.
 *
 * You are required to give attribution to the author (Gavin Stewart) for any
 * use of this program (GPLv3 Section 7b).
 * 
 * Trying to pass off my code as your own in your Elements of Computing classes
 * will result in a cursed life of forever buggy software.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
class Sinus {
    static Array table;
    static boolean initialised;
    
    /**
     * Initialise the sinus table.
     */
    function void init () {  
        var int i;
        
        // Static table only initialised once.
        if (initialised) {
            return;
        }
        
        let table = Array.new(360);
        
        // Index in degrees (0 to 359 inclusive).
        // Output is two decimal places fixed point (* 100)
        //     => sin(degrees) * 100 
        
        // First 90 degrees generated by script: generate_sinus.py
        let i = 0;
        let i = Sinus._push91(i,0,2,3,5,7,9,10,12);
        let i = Sinus._push91(i,14,16,17,19,21,22,24,26);
        let i = Sinus._push91(i,28,29,31,33,34,36,37,39);
        let i = Sinus._push91(i,41,42,44,45,47,48,50,52);
        let i = Sinus._push91(i,53,54,56,57,59,60,62,63);
        let i = Sinus._push91(i,64,66,67,68,69,71,72,73);
        let i = Sinus._push91(i,74,75,77,78,79,80,81,82);
        let i = Sinus._push91(i,83,84,85,86,87,87,88,89);
        let i = Sinus._push91(i,90,91,91,92,93,93,94,95);
        let i = Sinus._push91(i,95,96,96,97,97,97,98,98);
        let i = Sinus._push91(i,98,99,99,99,99,100,100,100);
        let i = Sinus._push91(i,100,100,100,0,0,0,0,0);
        
        // Generate remaining three quadrants from exisiting data.
        
        let i = 91;
        while (i < 181) {
            let table[i] = table[180 - i];
            let i = i + 1;
        }
        
        // Note: i == 181
        while (i < 271) {
            let table[i] = -(table[i - 180]);
            let i = i + 1;
        }
        
        // Note: i == 271
        while (i < 360) {
            let table[i] = -(table[360 - i]);
            let i = i + 1;
        }
        
        let initialised = true;
        
        return;
    }
    
    /**
     * Internal helper function to push 91 elements into table array.
     *
     * @param int i
     *  Index to start pushing at.
     * @param int a through h
     *  8 data values to push into table, padded with zeros for last call.
     *
     * @returns int
     *  Index for next call.
     */
    function int _push91 (int i, int a, int b, int c, int d, int e, int f,
                           int g, int h) {
        var int remain;
        
        let remain = 91 - i;
        
        if (remain > 0) { let table[i  ] = a; }
        if (remain > 1) { let table[i+1] = b; }
        if (remain > 2) { let table[i+2] = c; }
        if (remain > 3) { let table[i+3] = d; }
        if (remain > 4) { let table[i+4] = e; }
        if (remain > 5) { let table[i+5] = f; }
        if (remain > 6) { let table[i+6] = g; }
        if (remain > 7) { let table[i+7] = h; }
        
        return(i + 8);
    }
    
    /**
     * Return the sinus table.
     */
    function Array getTable () {
        return(table);
    }
    
    /**
     * Return sin(A) * 100
     *
     * Where 0 <= A < 360
     */
    function int sin (int A) {
        return(table[A]);
    }
    
    /**
     * Return cos(A) * 100
     *
     * Where 0 <= A < 360
     */
    function int cos (int A) {
        let A = A + 90;   // Cos is sin + 90 degrees.
        if (A > 359) {    // Ensure A is < 360
            let A = A - 360;
        }
        return(table[A]);
    }
    
    /**
     * Build a new resampled sinus array.
     *
     * @param int startDegrees
     *  Where: 0 <= startDegrees < endDegrees
     * @param int endDegrees
     *  Where: startDegrees < endDegrees <= 360
     *  Will never quite reach endDegrees as maximum.
     * @param int steps
     *  Number of steps in final array. May be more or less than difference
     *  between endDegrees and startDegrees.
     *
     * @return Array
     *  Rescaled sinus array.
     */
    function Array resample (int startDegrees, int endDegrees, int steps) {
        var int i;
        var int degrees, dD;
        var int intPart, fractPart, err;
        var Array sinus;
    
        let sinus = Array.new(steps);
        
        let dD = endDegrees - startDegrees;
                        
        // This is actually a form of the Bresenham line algorithm, simlar
        // to Image.drawVScale(). It will scale up or down to fit steps into
        // dD degrees of Sinus table.
        let intPart = dD / steps;
        let fractPart = MathsToo.mod(dD, steps);
        
        let err = 0;
        while (i < steps) {
            let sinus[i] = Sinus.sin(startDegrees + degrees);
            let degrees = degrees + intPart;
            let err = err + fractPart;
            if (err > degrees) {
                let err = err - steps;
                let degrees = degrees + 1;
            }
            let i = i + 1;
        }
        
        return sinus;
    }

}
